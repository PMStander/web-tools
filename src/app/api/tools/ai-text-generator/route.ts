import { NextRequest, NextResponse } from 'next/server'
import { FileService, AppError } from '@/lib/file-service';
import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import { v4 as uuidv4 } from 'uuid'
import { existsSync } from 'fs'

interface GenerateRequest {
  prompt: string
  type: 'blog-post' | 'email' | 'social-media' | 'product-description' | 'article' | 'summary' | 'custom'
  tone?: 'professional' | 'casual' | 'friendly' | 'formal' | 'creative' | 'persuasive'
  length?: 'short' | 'medium' | 'long' | 'custom'
  customLength?: number
  language?: string
  includeOutline?: boolean
  keywords?: string[]
  targetAudience?: string
  outputFormat?: 'text' | 'markdown' | 'html'
}

interface GenerateResponse {
  success: boolean
  outputFileId?: string
  outputFileName?: string
  downloadUrl?: string
  generatedText?: string
  wordCount?: number
  characterCount?: number
  processingTime?: number
  error?: string
}

// FileService handles directory paths

async function ensureOutputDir() {
  if (!existsSync(OUTPUT_DIR)) {
    await mkdir(OUTPUT_DIR, { recursive: true })
  }
}

// Mock AI text generation - in production, integrate with OpenAI, Claude, or other LLM APIs
async function generateText(request: GenerateRequest): Promise<string> {
  const { prompt, type, tone = 'professional', length = 'medium', targetAudience, keywords = [] } = request
  
  // Simulate processing time
  await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000))
  
  // Generate content based on type and parameters
  let generatedContent = ''
  
  const toneModifiers = {
    professional: 'in a professional and polished manner',
    casual: 'in a casual and conversational tone',
    friendly: 'in a warm and friendly way',
    formal: 'in a formal and structured style',
    creative: 'with creativity and flair',
    persuasive: 'in a compelling and persuasive manner'
  }
  
  const lengthGuidelines = {
    short: '2-3 paragraphs',
    medium: '4-6 paragraphs',
    long: '8-12 paragraphs'
  }
  
  switch (type) {
    case 'blog-post':
      generatedContent = `# ${prompt}

## Introduction
This ${tone} blog post explores the topic of "${prompt}" ${toneModifiers[tone]}. 

## Main Content
[Generated content would appear here based on the prompt: "${prompt}"]

This content is designed for ${targetAudience || 'a general audience'} and incorporates the following key concepts: ${keywords.join(', ') || 'relevant industry terms'}.

## Key Points
- Comprehensive coverage of ${prompt}
- ${tone.charAt(0).toUpperCase() + tone.slice(1)} approach to the subject matter
- Targeted for ${targetAudience || 'your specific audience'}
- Length: ${lengthGuidelines[length] || 'customized length'}

## Conclusion
This ${tone} piece effectively addresses the topic while maintaining engagement with the target audience.

---
*Generated by AI Text Generator - Please review and customize as needed*`
      break
      
    case 'email':
      generatedContent = `Subject: ${prompt}

Dear [Recipient],

I hope this email finds you well. I'm writing to you regarding ${prompt}.

[Main email content would be generated here based on your specific requirements and the ${tone} tone you've selected.]

Key points to address:
${keywords.map(keyword => `- ${keyword}`).join('\n') || '- [Key points based on your prompt]'}

${targetAudience ? `This email is crafted specifically for ${targetAudience}.` : ''}

Thank you for your time and consideration.

Best regards,
[Your Name]

---
*Generated by AI Text Generator - Please customize sender information and review content*`
      break
      
    case 'social-media':
      generatedContent = `ðŸš€ ${prompt}

${toneModifiers[tone].charAt(0).toUpperCase() + toneModifiers[tone].slice(1)}, this post is designed to engage your audience with relevant content.

${keywords.length > 0 ? `#${keywords.join(' #')}` : '#socialmedia #content #engagement'}

${targetAudience ? `Perfect for: ${targetAudience}` : ''}

---
*Generated by AI Text Generator - Customize hashtags and mentions as needed*`
      break
      
    case 'product-description':
      generatedContent = `# ${prompt}

## Product Overview
[Compelling product description generated based on: "${prompt}"]

## Key Features
${keywords.map(keyword => `- ${keyword}`).join('\n') || '- [Features derived from your input]'}

## Benefits
This product delivers exceptional value ${toneModifiers[tone]} for ${targetAudience || 'customers'}.

## Specifications
[Technical details and specifications would be included here]

---
*Generated by AI Text Generator - Please verify all product details and specifications*`
      break
      
    case 'article':
      generatedContent = `# ${prompt}

## Abstract
This article provides comprehensive coverage of "${prompt}" ${toneModifiers[tone]}.

## Introduction
[Introduction content addressing the topic with the ${tone} tone specified]

## Main Sections
### Section 1: Background
[Relevant background information]

### Section 2: Analysis
[Detailed analysis incorporating: ${keywords.join(', ') || 'key concepts'}]

### Section 3: Implications
[Discussion of implications and applications]

## Conclusion
[Summary and conclusions drawn from the analysis]

## References
[Citations and references would be included in a complete article]

---
*Generated by AI Text Generator - Academic and professional review recommended*`
      break
      
    case 'summary':
      generatedContent = `## Summary: ${prompt}

**Key Points:**
${keywords.map(keyword => `â€¢ ${keyword}`).join('\n') || 'â€¢ [Main points extracted from your content]'}

**Overview:**
This summary captures the essential elements of "${prompt}" ${toneModifiers[tone]}.

**Target Audience:** ${targetAudience || 'General readers'}

**Length:** ${lengthGuidelines[length] || 'Optimized for readability'}

---
*Generated by AI Text Generator - Please review for accuracy and completeness*`
      break
      
    default:
      generatedContent = `# ${prompt}

This content has been generated ${toneModifiers[tone]} based on your specific requirements.

**Content Type:** ${type}
**Tone:** ${tone}
**Target Audience:** ${targetAudience || 'Not specified'}
**Keywords:** ${keywords.join(', ') || 'None specified'}

[Main content would be generated here based on your prompt: "${prompt}"]

The content is structured to meet your ${length} length requirements and maintains the ${tone} tone throughout.

---
*Generated by AI Text Generator - Please review and customize as needed*`
  }
  
  return generatedContent
}

// Convert content to specified format
function formatContent(content: string, format: string): string {
  switch (format) {
    case 'markdown':
      return content // Already in markdown
      
    case 'html':
      // Simple markdown to HTML conversion
      return content
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^\* (.*$)/gm, '<li>$1</li>')
        .replace(/^- (.*$)/gm, '<li>$1</li>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/\n\n/g, '</p><p>')
        .replace(/^/, '<p>')
        .replace(/$/, '</p>')
        
    case 'text':
    default:
      // Strip markdown formatting for plain text
      return content
        .replace(/^#{1,6} /gm, '')
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/^\* /gm, 'â€¢ ')
        .replace(/^- /gm, 'â€¢ ')
  }
}

export async function POST(request: NextRequest) {
  const startTime = Date.now()
  
  try {
    await ensureOutputDir()
    
    const body: GenerateRequest = await request.json()
    const { 
      prompt, 
      type = 'custom', 
      tone = 'professional', 
      length = 'medium',
      outputFormat = 'markdown',
      includeOutline = false,
      keywords = [],
      targetAudience,
      language = 'English'
    } = body
    
    if (!prompt || prompt.trim().length === 0) {
      return NextResponse.json<GenerateResponse>({
        success: false,
        error: 'Prompt is required'
      }, { status: 400 })
    }
    
    if (prompt.length > 1000) {
      return NextResponse.json<GenerateResponse>({
        success: false,
        error: 'Prompt must be less than 1000 characters'
      }, { status: 400 })
    }
    
    const supportedTypes = ['blog-post', 'email', 'social-media', 'product-description', 'article', 'summary', 'custom']
    if (!supportedTypes.includes(type)) {
      return NextResponse.json<GenerateResponse>({
        success: false,
        error: `Unsupported content type. Supported types: ${supportedTypes.join(', ')}`
      }, { status: 400 })
    }
    
    // Generate text content
    const generatedText = await generateText(body)
    
    // Format content according to output format
    const formattedContent = formatContent(generatedText, outputFormat)
    
    // Calculate metrics
    const wordCount = formattedContent.split(/\s+/).filter(word => word.length > 0).length
    const characterCount = formattedContent.length
    
    // Generate output filename
    const outputFileId = uuidv4()
    const fileExtension = outputFormat === 'html' ? 'html' : outputFormat === 'markdown' ? 'md' : 'txt'
    const outputFileName = `${outputFileId}_generated-content.${fileExtension}`
    const outputPath = FileService.generateOutputPath(outputFileId, outputFileName)
    
    // Save generated content
    await writeFile(outputPath, formattedContent, 'utf-8')
    
    const processingTime = Date.now() - startTime
    
    // Log generation operation
    const generationMetadata = {
      outputFileId,
      fileName: outputFileName,
      filePath: outputPath,
      fileSize: Buffer.from(formattedContent, 'utf-8').length,
      mimeType: outputFormat === 'html' ? 'text/html' : outputFormat === 'markdown' ? 'text/markdown' : 'text/plain',
      prompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''),
      type,
      tone,
      length,
      outputFormat,
      wordCount,
      characterCount,
      keywords: keywords.slice(0, 10), // Limit keywords in logs
      targetAudience,
      language,
      processingTime,
      createdAt: new Date().toISOString()
    }
    
    console.log('AI text generation completed:', generationMetadata)
    
    return NextResponse.json<GenerateResponse>({
      success: true,
      outputFileId,
      outputFileName,
      downloadUrl: `/api/files/download?fileId=${outputFileId}`,
      generatedText: formattedContent,
      wordCount,
      characterCount,
      processingTime
    })
    
  } catch (error) {
    const processingTime = Date.now() - startTime
    console.error('AI text generation error:', error)
    
    return NextResponse.json<GenerateResponse>({
      success: false,
      error: error instanceof Error ? error.message : 'Internal server error during text generation',
      processingTime
    }, { status: 500 })
  }
}

// GET endpoint for generation info and capabilities
export async function GET(request: NextRequest) {
  return NextResponse.json({
    success: true,
    capabilities: {
      supportedTypes: ['blog-post', 'email', 'social-media', 'product-description', 'article', 'summary', 'custom'],
      supportedTones: ['professional', 'casual', 'friendly', 'formal', 'creative', 'persuasive'],
      supportedLengths: ['short', 'medium', 'long', 'custom'],
      supportedFormats: ['text', 'markdown', 'html'],
      supportedLanguages: ['English'], // Expand as needed
      maxPromptLength: 1000,
      maxKeywords: 10,
      features: [
        'Custom content generation',
        'Multiple content types',
        'Tone customization',
        'Keyword integration',
        'Target audience specification',
        'Multiple output formats'
      ]
    }
  })
}